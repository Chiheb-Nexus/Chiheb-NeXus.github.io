<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nexus Coding | Pour un monde meilleur !</title>
    <description>Blog dédié à la technologie de la Blockchain et au développement informatique en général</description>
    <link>https://chiheb-nexus.github.io/</link>
    <atom:link href="https://chiheb-nexus.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 02 May 2020 21:26:10 +0200</pubDate>
    <lastBuildDate>Sat, 02 May 2020 21:26:10 +0200</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Python: Multithreading VS Multiprocessing</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://media-exp1.licdn.com/dms/image/C4E12AQEd94lruVBQFQ/article-cover_image-shrink_600_2000/0?e=1588809600&amp;amp;v=beta&amp;amp;t=gvb2Gxqft7d4QCcyCMDYh2LkmeQsgeQJSKNqK3UKcgY&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt; &lt;p&gt;Les modules de threading et de multiprocessing en python visent à faire la même chose, c’est-à-dire à faire plusieurs choses en même temps, mais la façon dont le module de threading et le module de multiprocessing s’y prendent est très différente.&lt;/p&gt; &lt;p&gt;C’est pourquoi une définition générale s’impose:&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Process:&lt;/strong&gt; Est une instance d’un programme qui tourne dans un ordinateur (une machine)&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Propriété des ressources: Espace d’adressage virtuel pour contenir l’image de processus, y compris le programme, les données, la pile et les attributs&lt;/li&gt; &lt;li&gt;L’exécution d’un processus suit un chemin à travers le programme&lt;/li&gt; &lt;li&gt;Commutateur de...</description>
        <pubDate>Sat, 02 May 2020 18:46:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/Multithreading-vs-multiprocessing/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/Multithreading-vs-multiprocessing/</guid>
        
        <category>python</category>
        
        <category>multithreading</category>
        
        <category>htreading</category>
        
        <category>muliprocessing</category>
        
        
        <category>python</category>
        
        <category>threading</category>
        
        <category>multiprocessing</category>
        
      </item>
    
      <item>
        <title>Fullstack Python web app: Flask &amp; React &amp; Webpack</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://repository-images.githubusercontent.com/197383174/16a44e80-a92d-11e9-973b-2b285df0da3b&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt; &lt;p&gt;Le monde du développent des sites web est tellement vaste que chaque jour nous, les développeurs, sommes amenés à utiliser/apprendre des nouvelles technologies. La tendance à la mode, aujourd’hui, c’est du faire des SPA (Single Page Application) en utilisant, généralement, React, Angular et VueJS (je note aussi Svelte) frameworks. Cependant, comme étant un développeur Python à la base, j’ai cherché sur net un tutoriel qui étale comment on devra procéder pour créer un site web en utilisant &lt;code class=&quot;highlighter-rouge&quot;&gt;Flask&lt;/code&gt; et &lt;code class=&quot;highlighter-rouge&quot;&gt;React&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Hélas, tout ce que j’ai trouvé ce sont soi des tutoriels qui utilisent...</description>
        <pubDate>Tue, 31 Dec 2019 17:46:31 +0100</pubDate>
        <link>https://chiheb-nexus.github.io/flask-react-app/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/flask-react-app/</guid>
        
        <category>flask</category>
        
        <category>React</category>
        
        <category>Webpack</category>
        
        <category>npm</category>
        
        <category>virtualenv</category>
        
        
        <category>flask</category>
        
        <category>react</category>
        
        <category>webpack</category>
        
      </item>
    
      <item>
        <title>Comment utiliser Pandas avec Django ORM</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://community-cdn-digitalocean-com.global.ssl.fastly.net/assets/tutorials/images/large/python.png?1513021422&quot; /&gt;&lt;/p&gt; &lt;p&gt;Après presque une année d’absence pour des diverses raisons, je me suis dit qu’il est temps de retourner à mon blog et d’ajouter des nouveaux articles et surtout des tutoriels qu’on ne trouve pas facilement sur le net. Ceci dit, je vais vous parler aujourd’hui de comment faire pour utiliser Pandas et Django ORM pour aboutir aux memes résultats. Je tiens à noter qu’on va ignorer les points de différences et similitudes entre les deux outils et on va se consacrer uniquement, au moins dans ce tutoriel, à lire un document EXCEL (.XLSX), de remplir une base...</description>
        <pubDate>Fri, 10 May 2019 22:46:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/django-orm-pandas/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/django-orm-pandas/</guid>
        
        <category>python</category>
        
        <category>pandas</category>
        
        <category>django</category>
        
        <category>orm</category>
        
        
        <category>django</category>
        
        <category>pandas</category>
        
      </item>
    
      <item>
        <title>Ethereum POA en utilisant Geth</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://www.newsonjapan.com/images/article/oracles6.png&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;définition-du-consensus-proof-of-authority-poa-preuve-dautorité&quot;&gt;Définition du consensus Proof Of Authority (POA, Preuve d’autorité):&lt;/h2&gt; &lt;p&gt;Proof-of-authority (PoA) est un algorithme utilisé avec la technologie de blockchain qui fournit des transactions relativement rapides grâce à un mécanisme de consensus basé sur l’identité en tant que pieu (l’identité étant une preuve suffisante pour la validation des transactions).&lt;/p&gt; &lt;p&gt;Dans les réseaux basés sur le POA, les transactions et les blocs sont validés par des comptes approuvés, appelés validateurs. Les validateurs exécutent un logiciel leur permettant de mettre des transactions dans des blocs. Le processus est automatisé et n’exige pas que les validateurs surveillent constamment leurs...</description>
        <pubDate>Mon, 28 May 2018 17:21:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/ethereumpoa/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/ethereumpoa/</guid>
        
        <category>ethereum</category>
        
        <category>web3</category>
        
        <category>web3.py</category>
        
        <category>geth</category>
        
        <category>blockchain</category>
        
        <category>POA</category>
        
        <category>Proof Of Authority</category>
        
        <category>consensus</category>
        
        
        <category>ethereum</category>
        
        <category>blockchain</category>
        
        <category>POA</category>
        
        <category>consensus</category>
        
      </item>
    
      <item>
        <title>Ethereum RLP: Explication</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*-Q00GpGTphTOtBWPRu1e3g.png&quot; /&gt;&lt;/p&gt; &lt;p&gt;Avant de continuer la lecture, je tiens à dire que cet article est une tentative d’explication du schéma d’encodage RLP, utilisé par Ethereum, d’une manière simple et concrète avec des exemples.&lt;/p&gt; &lt;p&gt;Ce qui va suivre, c’est une tentative d’explication de ce que j’ai pu comprendre de l’encodage RLP qu’Ethereum utilise. Et c’est à vous de chercher encore et de valider ou non ce que vous aller rencontrer tout le long de cet article.&lt;/p&gt; &lt;h2 id=&quot;définition&quot;&gt;Définition:&lt;/h2&gt; &lt;p&gt;Le schéma d’encodage RLP (Recursive Length Prefix) est un schéma de sérialisation d’objets spatialement efficace utilisé dans Ethereum.&lt;/p&gt; &lt;p&gt;La spécifité de ce...</description>
        <pubDate>Mon, 21 May 2018 04:17:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/ethereumrlp/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/ethereumrlp/</guid>
        
        <category>ethereum</category>
        
        <category>sha3</category>
        
        <category>rlp</category>
        
        <category>encoding</category>
        
        <category>decoding</category>
        
        
        <category>bitcoin</category>
        
        <category>blockchain</category>
        
      </item>
    
      <item>
        <title>Ethereum Smart Contract</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/0*PFwVdgw-2tqj8LZV.png&quot; /&gt;&lt;/p&gt; &lt;p&gt;Les contrats intelligents (en anglais Smart Contracts) sont des protocoles informatiques qui facilitent, vérifient et exécutent la négociation ou l’exécution d’un contrat, ou qui rendent une clause contractuelle inutile (car rattachée au contrat intelligent). Les contrats intelligents ont généralement une interface utilisateur et émulent la logique des clauses contractuelles.&lt;/p&gt; &lt;p&gt;Les partisans des contrats intelligents affirment que de nombreux types de clauses contractuelles peuvent ainsi être partiellement ou totalement auto-exécutées ou exécutées à la validation ou les deux.&lt;/p&gt; &lt;p&gt;Les contrats intelligents visent à assurer une sécurité supérieure à la mise en application de la loi sur les contrats...</description>
        <pubDate>Sun, 13 May 2018 20:21:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/smartcontract/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/smartcontract/</guid>
        
        <category>ethereum</category>
        
        <category>web3</category>
        
        <category>web3.py</category>
        
        <category>infura.io</category>
        
        <category>blockchain</category>
        
        <category>smart contract</category>
        
        <category>solidity</category>
        
        
        <category>ethereum</category>
        
        <category>blockchain</category>
        
      </item>
    
      <item>
        <title>Génération des adresses Bitcoin</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://qph.fs.quoracdn.net/main-qimg-6c2c189f74309b175549396b1eb00b7f&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;adresse-bitcoin-&quot;&gt;Adresse Bitcoin ?&lt;/h2&gt; &lt;p&gt;Une adresse Bitcoin, ou simplement une adresse, est un identifiant de 26 à 35 caractères alphanumériques, commençant par le chiffre 1 ou 3, qui représente une destination possible pour un paiement bitcoin. Les adresses peuvent être générées gratuitement par n’importe quel utilisateur de Bitcoin. Par exemple, en utilisant &lt;a href=&quot;https://en.bitcoin.it/wiki/Bitcoin_Core&quot;&gt;Bitcoin Core&lt;/a&gt;, vous pouvez cliquer sur “New Address” et créer une adresse. Il est également possible d’obtenir une adresse Bitcoin en utilisant un compte auprès d’un service d’échange ou de portefeuille en ligne. [&lt;a href=&quot;https://en.bitcoin.it/wiki/Address&quot;&gt;Source: bitcoin wiki&lt;/a&gt;]&lt;/p&gt; &lt;p&gt;Il y a actuellement trois formats d’adresses...</description>
        <pubDate>Thu, 10 May 2018 22:46:31 +0200</pubDate>
        <link>https://chiheb-nexus.github.io/btcaddress/</link>
        <guid isPermaLink="true">https://chiheb-nexus.github.io/btcaddress/</guid>
        
        <category>bitcoin</category>
        
        <category>sha256</category>
        
        <category>ripemd160</category>
        
        <category>base58</category>
        
        <category>blockchain</category>
        
        
        <category>bitcoin</category>
        
        <category>blockchain</category>
        
      </item>
    
  </channel>
</rss>
